# 4.4 List of `automr` Keywords

Here are the list of all `automr` keywords, grouped by category.

| For program specification | | | |
| --- | --- | --- | --- |
| [HF_prog](#449-hf_prog) | [GVB_prog](#4410-gvb_prog) | [CASCI_prog](#4411-casci_prog) | [CASSCF_prog](#4412-casscf_prog) |
| [DMRGCI_prog](#4413-dmrgci_prog) | [DMRGSCF_prog](#4414-dmrgscf_prog) | [CASPT_prog](#4415-caspt_prog) | [NEVPT_prog](#4416-nevpt_prog) |
| [MRCISD_prog](#4417-mrcisd_prog) | [MRMP2_prog](#4419-mrmp2_prog) | [MCPDFT_prog](#4420-mcpdft_prog) | |

<br/>

| For workflow specification | | | | 
| --- | --- | --- | --- | 
| Input wavefunction | [readrhf](#441-readrhf) | [readuhf](#442-readuhf) | [readno](#443-readno) |
| Workflow settings | [ist](#444-ist) (most important!) | [LocalM](#445-localm) |  [CIonly](#446-cionly) |
| | [ON_thres](#4435-on_thres) | [UNO_thres](#4436-uno_thres) | [Skip_UNO](#4444-skip_uno) |
| | [excludeXH](#4437-excludexh), [OnlyXH](#4448-onlyxh) | [HFonly](#4451-hfonly) |

<br/>

| For method details | | | | |
| --- | --- | --- | --- | --- |
| General |   [Cart](#448-cart) | [hardwfn](#4423-hardwfn), [crazywfn](#4424-crazywfn) | [charge](#4425-charge) | [DKH2](#4427-dkh2), [X2C](#4428-x2c) |
| For MR methods | [CtrType](#4421-ctrtype) for MRCI | [MaxM](#4422-maxm) for DMRG | [OtPDF](#4426-otpdf)| [FIC](#4434-fic) for NEVPT2 |
| For GVB | [GVB_conv](#4443-gvb_conv) | [Inherit](#4445-inherit) | [Npair](#4446-npair) | [FcGVB](#4447-fcgvb) |
| Wavefunction settings | [noDMRGNO](#4450-nodmrgno) |

<br/>

| Others | | | | 
| --- | --- | --- | --- | 
| Acceleration technique | [RI](#4429-ri), [RIJK_bas](#4430-rijk_bas) | [F12](#4431-f12), [F12_cabs](#4432-f12_cabs) for NEVPT2 | [DLPNO](#4433-dlpno) for NEVPT2 |
|For additional properties | [Force](#447-force) | [NMR](#4438-nmr) | [ICSS](#4439-icss) |
| For excited states  | [Nstates](#4440-nstates) | [Mixed_Spin](#4441-mixed_spin) | [Root](#4442-root), [Xmult](#4449-xmult) |

<br/>

If any of the `readrhf`, `readuhf`, and `readno` keywords is used, there is no need to write Cartesian coordinates in .gjf file, since the geometry will be read from the specified .fch(k) file.

## 4.4.1 readrhf
Read RHF/ROHF orbitals from a specified .fch file. Do not provide a UHF-type .fch file using this keyword. This keyword is usually used along with another keyword `ist=3` (see [ist](#444-ist)).

## 4.4.2 readuhf
Read UHF orbitals from a specified .fch(k) file. `automr` will firstly check the difference between alpha and beta MOs. If the difference is tiny, the wave function in .fch file will be identified as a RHF one and will call utility fch_u2r to generate a RHF-type .fch file (in which all beta information is deleted). Otherwise (i.e. truly UHF), `automr` will generate UHF natural orbitals (UNO) using input UHF orbitals. It is strongly recommended to check the stability of UHF wave function (using keyword 'stable=opt' in Gaussian). An instable or not-the-lowest UHF solution sometimes leads to improper GVB or CASSCF results.

It is not recommended to provide UDFT orbitals.

This keyword is usually used along with another keyword ist=1 or 2 (see [ist](#444-ist)). Note that do not provide a UNO .fch file with this keyword. If you want to use any type of NOs as the initial guess, see `readno` in the following section.

## 4.4.3 readno
Read natural orbital occupation numbers (NOON) and natural orbitals (NO) from a specified .fch file. In this case, you must ensure that the 'Alpha Orbital Energies' section in the .fch file contains occupation numbers, not energy levels or something else, since the size of the active space will be determined according to the (threshold of the) occupation numbers.

With this keyword, you may try different NOs as the initial guess, like MP2 NOs, CCSD NOs, or some type of NOs generated by your own program. You may also use UNOs from UHF as the initial guess. In this case, it is equivalent to use the keyword `readuhf` to read in the UHF orbitals and generate UNOs by MOKIT.
This keyword is usually used along with another keyword ist=5 (see [ist](#444-ist)).

## 4.4.4 ist
Request the use of the *i*-th strategy. Default is 0. This means: (1) if the spin of the target molecule is singlet, MOKIT will call the Gaussian software to perform RHF and UHF computations, then determine whether to change `ist` to 1 or 3. If the E<sub>UHF</sub> = E<sub>RHF</sub>, ist will be changed to 3. If E<sub>UHF</sub> <E<sub>RHF</sub>, ist will become 1. (2) if not singlet, ist will be changed to 1 immediately.

For simple organic molecules which have multireference characters (like diradicals), the UHF performed by MOKIT (calling Gaussian) can always find the lowest (and stable) UHF solution. But for complicated systems like binuclear transition metal complex, there often exist multiple UHF solutions. And the UHF solution found by MOKIT is not necessarily the lowest one. In this case you are recommended to do UHF computations by yourself and use ist=1 to read in the Gaussian .fch file. See a practical guide for advanced UHF computations on http://gaussian.com/afc. If you can read Chinese, you are recommended to read [Sobereva's blog](http://sobereva.com/82).

Currently, there are 7 allowed values for ist:  
0: meaning that if RHF wave function is stable, use strategy 3; otherwise use strategy 1  
1: UHF -> UNO -> associated rotation -> GVB -> CASCI/CASSCF -> ...  
2: UHF -> UNO -> (associated rotation ->) CASCI/CASSCF -> ...  
3: RHF -> virtual orbital projection -> localization -> pairing -> GVB -> CASCI/CASSCF -> ...  
4: RHF -> virtual orbital projection -> CASCI/CASSCF -> ...  
5: NOs -> CASCI/CASSCF -> ...  
6: minimal basis GVB -> target basis GVB -> CASCI/CASSCF -> ...

The value 0 (default) is recommended, if you do not know which one to choose.

## 4.4.5 LocalM
Specify the orbital localization method. Only the Boys (also called Foster-Boys) localization and PM (Pipek-Mezey) localization method are supported. The corresponding keywords are `LocalM=Boys` and `LocalM=PM`(default), respectively.

Note that there are 3 localization steps controlled by this keyword: (1) the orbital localization during constructing GVB initial guess; (2) the orbital localization of singly occupied orbitals (only if you perform a high-spin GVB calculation, here high-spin means triplet or higher); (3) the orbital localization of doubly occupied orbitals (only if you specify the keyword [LocDocc](#4453-locdocc)).

Note: the Boys method will mix \\( \sigma \\) and \\( \pi \\) orbitals, while the PM method tends to keep them separated. These two methods make no difference when the target molecule contains only \\( \sigma \\) bonds (and possibly a few isolated \\( \pi \\) bonds). But if you are dealing with multiple \\( \pi \\) bonds or conjugated \\( \pi \\) systems like oligoacene (benzene, naphthalene, etc), or if you want the active space to contain only \\( \pi \\) orbitals, better use the PM method. The GVB and CASSCF optimized orbitals will be affected by the localization method sometimes. If you explicitly specify the size of active space which is equal to the \\( \pi \\) space (note that frontier natural orbitals are usually \\( \pi \\) orbitals), then using `LocalM=Boys` is OK since Boys localization among pure \\( \pi \\) orbitals is safe (no sigma orbital is in the set).

For people who are keen on comparing initial guesses generated from different methods/algorithms, `LocalM=Boys` is strongly recommended to be taken into consideration, to see whether a lower GVB, CASCI or CASSCF energy occurs.

## 4.4.6 CIonly
Skip the CASSCF orbital optimization in the CASPT2 or NEVPT2 job. Obviously, this keyword only applies to CASPT2 or NEVPT2 case. Writing CIonly means a CASCI -> CASPT2 or CASCI -> NEVPT2 job. In fact, the CASSCF orbital optimization is always recommended to be performed, unless it is too time-consuming, or you happen to want this type of result.

Note: if you simply need a CASCI computation, do not use CIonly in a CASSCF job, but simply write CASCI/basis_set in the keyword line of .gjf file.

## 4.4.7 Force
Request a calculation of the analytical nuclear gradient. Currently this keyword only applies to CASSCF. Geometry optimization is currently not supported, but you can use the generated files to perform optimization using corresponding software. Numerical gradient is not supported.
Note that this keyword do not have any attribute value, i.e. do not write 'force=.True.' but only `force` in {}. Also keep in mind that force is negative gradient.

## 4.4.8 Cart
Request the use of Cartesian type atomic basis functions. The default basis type in `automr` (i.e. spherical harmonic functions) will then be disabled. These two types of basis functions correspond to '6D 10F' (Cartesian functions) and '5D 7F' (spherical harmonic functions) in Gaussian. It is strongly recommended to use spherical harmonic functions, especially in all-electron relativistic computations (DKH2, X2C, etc).

Note that for computations involving the ORCA program, this keyword cannot be used since ORCA only support spherical harmonic functions.

If you do not know the meaning of 5D or 6D, you are referred to Schlegel and Frisch's paper (DOI: 10.1002/qua.560540202), and a good explanation from [Chemissian](http://www.chemissian.com/ch5). If you can read Chinese, you are recommended to read [Sobereva's blog](http://sobereva.com/51).

## 4.4.9 HF_prog
Specify the program for performing Hartree-Fock (HF) calculations. Supported programs are Gaussian(default), PySCF, PSI4 and ORCA. If the input molecule is singlet, RHF and broken symmetry UHF (plus wave function stability analysis) will be successively performed. If not singlet, only UHF (plus wave function stability analysis) will be performed.

It is strongly recommended to use the default HF_prog (i.e. Gaussian), since the SCF algorithm in Gaussian is the most effective/robust in almost all cases, among all quantum software packages. The only case when you are recommended to use PySCF/PSI4/ORCA, is that if your studied molecule is large and cannot be further simplified (Nbasis>1500), you can consider turn on the RI approximation of HF to accelerate computations in PySCF, PSI4 or ORCA. For example, in this special case you are supposed to write
```
mokit{RI,HF_prog=PySCF} # (or PSI4, ORCA if you wish)
```
in .gjf file. For people who cannot (or are not allowed to) use Gaussian, `HF_prog=PySCF` is a recommended choice.

## 4.4.10 GVB_prog
Specify the GVB program. Supported programs are GAMESS(default), Gaussian and QChem. The second-order SCF (SOSCF) algorithm in GAMESS is used to converge the GVB wave function. The GAMESS version >=2017 is strongly recommended. Older versions of GAMESS may work or may not, since they are not tested by the developers. It is always recommended to use the default program GAMESS, rather than Gaussian (due to poor convergence for transition metal).

Note the original GAMESS can only do GVB up to 12 pairs. Nowadays we can do a black-box GVB computation with hundreds of pairs. So, to go beyond 12 pairs, you need to modify and re-compile the source code of GAMESS.

MOKIT offers a Shell script to help you automatically handle this. Assuming you have compiled GAMESS before (i.e. all `*.o` files are still in `gamess/object/` directory of GAMESS), now you simply need to copy two files (`modify_GMS1.sh` and `modify_GMS2.f90`) from `mokit/src/` into `gamess/source/` directory, and run `./modify_GMS1.sh`. For example, these Linux commands on my computer are

```
cp $MOKIT_ROOT/src/modify_GMS1.sh ~/software/gamess/source/
cp $MOKIT_ROOT/src/modify_GMS2.f90 ~/software/gamess/source/
cd ~/software/gamess/source/
./modify_GMS1.sh
```

You may need to type `y` after running `./modify_GMS1.sh`. The script will modify source code and re-compile GAMESS, taking about 2 minutes. The linked GAMESS executable will be `gamess.01.x`. If you already had an executable named `gamess.01.x`, please rename it to another filename. Otherwise it will be destroyed and replaced during re-compilation.

> [!NOTE]
> Note for conda users: the MOKIT conda package does not contain `src/`. An alternative way is to go to [GitLab repo](https://gitlab.com/jxzou/mokit/-/tree/master/src?ref_type=heads) and download those two files.

Besides, for GAMESS earlier than version 2021-R1, it only supports 32 CPU cores. If your machine has more cores (and if you want to use >32 cores), you need to modify the variable MAXCPUS in file gamess/ddi/compddi. See a simple guide in file `src/modify_GMS_beyond32CPU.txt`. Since GAMESS 2021, the MAXCPUS is already set to 128, so modification is not needed.

It is strongly recommended to check whether the GAMESS runs normally after modifying. Such check can be done by running `./runall 01` in gamess/ directory, where `01` means checking the executable `gamess.01.x`. This is same as checking for version `00`. All tests are supposed to be passed successfully.

If a high-spin GVB computation is performed (it can be the target computation, or an intermediate step in a CASSCF computation) and there are more than 1 singly occupied orbital, the singly occupied orbitals will be localized and saved into `xxx_s.fch`. The corresponding orbital localization method is Pipek-Mezey and it can be controlled by [LocalM](#445-localm).

## 4.4.11 CASCI_prog
Specify the program for performing the CASCI calculation, e.g. `CASCI_prog=PySCF`. Supported programs are PySCF(default), Molpro, GAMESS, OpenMolcas, Gaussian, ORCA, BDF, PSI4 and Dalton.

If you use some old versions of BDF as the CASCI_prog, you may find the NOONs are zero. In that case you should update to the latest version of BDF.

## 4.4.12 CASSCF_prog
Specify the program for performing the CASSCF calculation, e.g. `CASSCF_prog=PySCF`. Supported programs are PySCF(default), Molpro, GAMESS, OpenMolcas, Gaussian, ORCA, BDF, PSI4 and Dalton. If you want to use a CASSCF program instead of PySCF, I recommend Molpro, OpenMolcas or GAMESS.

If you use some old versions of BDF as the CASSCF_prog, you may find the NOONs are zero. In that case you should update to the latest version of BDF.
For excited state calculations. Please read related comments in
[A2.3](./chap_appdx.html#a23-validity-of-mos-obtained-by-automr-for-excited-state-calculations).

## 4.4.13 DMRGCI_prog
The usage of this keyword is the same as [DMRGSCF_prog](#4414-dmrgscf_prog).

## 4.4.14 DMRGSCF_prog
Specify the program for performing DMRG-CASSCF calculation, e.g. `DMRGSCF_prog=PySCF`. Currently only PySCF is supported and it is the default program. According to the computational experience of `jxzou`, the Block-1.5/Block2 are the fastest DMRG program currently.

Note that in fact the DMRG-CASSCF calculations are performed by Block and PySCF, not only by PySCF. Thus you should install the Block-1.5 or Block2 program. And you should also cite corresponding reference of the Block program. For PySCF >= 2.0, you also need to install the [pyscf[dmrgscf]](https://pyscf.org/install.html#install-pyscf-extensions) extension.

Also note that the MPI version used by Block is probably contradicted with MPI version used by ORCA, thus you have to comment one version of MPI environment variables at a time. Or you can use a Shell script to submit the automr job, in which your desired MPI environment variables are written.

By default, the OpenMP version of Block would be called during performing DMRG calculations. But if you want to use MPI version of Block (and you have installed it), you need to write `mokit{block_mpi}`.

## 4.4.15 CASPT_prog
Specify the program for performing a CASPT2 or CASPT3 calculation, e.g. `CASPT_prog=OpenMolcas`. Currently only OpenMolcas(default), Molpro and ORCA are supported. Bagel is not supported here but we are working on that. All core orbitals are not frozen. Note that a default IP-EA shift 0.25 a.u. will be applied and it cannot be modified. If your CASPT2 results are sensitive to the IP-EA shift, it implies that CASPT2 is not suitable to your problem in that case. Another two types of shift (the real or imaginary shift) is not supported. If the user wants only CASPT2, the keyword `CASPT2_prog` can be used as an alias for `CASPT_prog`. For CASPT3, `CASPT_prog=Molpro` is the default and only option, thus no need to specify this keyword.

Generally speaking, NEVPT2 and CASPT2-K are more recommended than CASPT2 since there is no need for IP-EA shift, real or imaginary shift in NEVPT2 or CASPT2-K methods.

## 4.4.16 NEVPT_prog
Specify the program for performing an NEVPT calculation, e.g. `NEVPT_prog=PySCF`. Currently supported programs are PySCF(default), Molpro, ORCA, OpenMolcas and BDF. All core orbitals are not frozen. This keyword is applicable to NEVPT2, NEVPT3, NEVPT4(SD) calculations. For NEVPT3, `NEVPT_prog` can only be equal to `ORCA` or `BDF`. For NEVPT4(SD), `NEVPT_prog=ORCA` is the default and the only option, thus there is no need to specify the keyword in such case. Two input examples are shown below

(1) CASSCF and SC-NEVPT2 by calling PySCF
```
%mem=100GB
%nprocshared=32
#p NEVPT2/def2TZVP

mokit{}

0 1
...
```

(2) FIC-NEVPT3 by calling ORCA
```
%mem=200GB
%nprocshared=64
#p NEVPT3/def2TZVP

mokit{NEVPT_prog=ORCA}

0 1
...
```

Note that there exist at least two variants of the NEVPT2: SC-NEVPT2 and FIC-NEVPT2 (aka PC-NEVPT2). By default, for NEVPT_prog=PySCF/Molpro/ORCA/OpenMolcas, SC-NEVPT2 is chosen; while for `NEVPT_prog=BDF`, FIC-NEVPT2 is chosen. To turn on the FIC-NEVPT2 when using PySCF/Molpro/ORCA/OpenMolcas, please use the keyword [FIC](#4434-fic). Also note that

(1) When you specify `NEVPT_prog=Molpro` or OpenMolcas, both of the SC-NEVPT2 and FIC-NEVPT2 energies are actually printed in Molpro/OpenMolcas output (.out file). You can open the output file and read it manually, if you need that energy.

(2) If you specify `NEVPT_prog=OpenMolcas`, it actually turns into a DMRG-NEVPT2 computation, no matter how large/small the size of active space is. In this special case, you need to install the QCMaquis package (interfaced with OpenMolcas) for DMRG computations.

(3) `NEVPT2_prog` can be used an alias when you request an NEVPT2 calculation. There is no alias like `NEVPT3_prog` or `NEVPT4_prog`.

## 4.4.17 MRCISD_prog
Specify the program for performing MRCISD calculation. By default, `MRCISD_prog=OpenMolcas`. You MUST also specify a contraction type, please read [CtrType](#4421-ctrtype) carefully. Currently, `automr` supports the interfaces of three MRCISD variants:

(1) uncontracted MRCISD (uc-MRCISD)  
(2) internally contracted MRCISD (ic-MRCISD)  
(3) fully internally contracted MRCISD (FIC-MRCISD)

where the computational cost and accuracy is (1)>(2)>(3). The ic- and FIC-MRCISD are both approximations of uncontracted MRCISD. If the Davidson size-consistency correction energy is added, then the method should be denoted as MRCISD+Q. It is recommended to use ic-MRCISD+Q or FIC-MRCISD+Q in practical calculations since the uncontracted MRCISD is usually too expensive.

`automr` is able to call OpenMolcas/Molpro/ORCA/Gaussian/GAMESS/PSI4/Dalton programs to perform MRCISD. Currently all core orbitals are not frozen. `automr` is also able to call PySCF+Block2 to perform the DMRG-FIC-MRCISD calculation.

If `MRCISD_prog=OpenMolcas`, only variants (1) and (2) are supported. The Davidson correction can be provided for both methods.

If `MRCISD_prog=ORCA`, only (1) and (3) are supported. The Davidson correction can be provided for both methods. However, only spherical harmonic functions of basis sets are supported in ORCA. But this is often not a problem, since it is recommended to use spherical harmonic functions than Cartesian functions.
Note that you should use ORCA>=5.0.0 for FIC-MRCISD+Q computations since older versions have a tiny bug in the Davidson correction.

If `MRCISD_prog=Gaussian` or Dalton, only (1) is supported and no Davidson correction is given.

If `MRCISD_prog=GAMESS` or PSI4, only (1) is supported. The Davidson correction energy will also be printed.

If `MRCISD_prog=Molpro`, only (2) is supported. The Davidson correction energy will also be printed. Note that the `MRCIC` program of Molpro will be called to perform ic-MRCISD. This ic-MRCISD is not exactly identical to that of OpenMolcas, so their electronic energies are different with (but close to) each other. If you want to compare (relative) electronic energies of two molecules using ic-MRCISD method, please choose the same type, i.e. both using Molpro or both using OpenMolcas.

## 4.4.18 MRCISDT_prog
Specify the program for performing an MRCISDT calculation. `MRCISDT_prog` can be OpenMolcas(default), Dalton, PSI4 and GAMESS. No Davidson correction will be provided, and only uncontracted MRCISDT is supported. The Davidson size-consistency correction is not supported.

## 4.4.19 MRMP2_prog
Specify the program for performing an MRMP2 calculation. Only GAMESS is supported and this is the default.

## 4.4.20 MCPDFT_prog
Specify the program for performing a MC-PDFT calculation. Supported programs are OpenMolcas(default)/PySCF/GAMESS. If you use `MCPDFT_prog=PySCF`, you need to install [pyscf-forge](https://github.com/pyscf/pyscf-forge).

Note that MC-PDFT will be automatically switched to DMRG-PDFT if DMRG-CASCI/CASSCF is invoked in a previous step. In this special case you need to install the QCMaquis package if you use the default `MCPDFT_prog`, i.e. OpenMolcas. If you use `MCPDFT_prog=PySCF` in this case, you need to install Block-1.5/Block2. DMRG-PDFT is not supported in GAMESS currently.

Also note that in GAMESS, the MC-PDFT is only supported for version >= 2019(R2), and currently it can only be run in serial.

See related keywords [CASCI_prog](./chap4-3.html#433-casci), [CASSCF_prog](./chap4-3.html#432-casscf), [OtPDF](#4426-otpdf) and [Force](#447-force).

## 4.4.21 CtrType
Specify the contraction type of the MRCISD method. The default value is 0. When you specify the MRCISD method and the `MRCISD_prog`, you must assign an integer for this variable, where

1 for uc-MRCISD  
2 for ic-MRCISD  
3 for FIC-MRCISD.

Generally, the ic- and FIC-MRCISD methods are recommended. See [here](./chap5-1.html#513-mrcisdq-calculation-of-the-ground-state) for more explanations of MRCISD computations. If your calculation involves Cartesian-type basis functions, then you cannot use FIC-MRCISD in ORCA. In such case, you can choose ic-MRCISD in OpenMolcas instead.

## 4.4.22 MaxM
Specify the bond dimension MaxM in DMRG-related calculations. The default values is 1000 (e.g. `MaxM=1000`). When maxM increases, the DMRG-CASCI energy will become closer to the CASCI energy, but the computational cost increases as well. The value 1000 is suitable for common cases. But do check whether it is valid for your system. For example, three computations using different MaxM (e.g. 500, 1000, 1500) may be conducted to study whether the energy converges with MaxM.

## 4.4.23 hardwfn
This option can only be applied to CASCI/CASSCF calculations using PySCF, OpenMolcas,
GAMESS or PSI4. By specifying `hardwfn`, `automr` will add extra keywords into the
CAS input files to ensure a better convergence. Note that normally you do not need
this keyword, and it is useless if you specify other programs as the CAS solver.

## 4.4.24 crazywfn
This option can only be applied to CASCI/CASSCF calculations using PySCF, OpenMolcas,
GAMESS or PSI4. By specifying `crazywfn`, `automr` will add extra keywords (more than
those of `hardwfn`) into the CAS input files to ensure a better convergence. Note that
usually you do not need this keyword, and it is useless if you specify other programs
as the CAS solver.

For example, when the N<sub>2</sub> molecule is stretched to *d*(N-N) = 4.0 Å, this is a system which features strong correlation and requires a CAS(6,6) active space. The Davidson iterative diagonalization in determinant CASCI (using GAMESS) may not find the singlet state in the lowest 5 states. In this case, specifying `crazywfn` will increase the NSTATE to 10, so that the singlet state can be found.

## 4.4.25 Charge
This keyword has identical meaning with the same keyword in Gaussian software, i.e. including background point charges in calculations. This keyword is supported for almost all methods in `automr`. Methods which are incompatible with background point charges will signal errors immediately. The charge-charge and charge-nuclei interaction energies are both included in all electronic energies printed (UHF, GVB, CASSCF, NEVPT2, etc).

The including of background point charges is useful for QM/MM calculations or fragmentation-based linear scaling methods (like GEBF, Many-body expansion, etc).

Note: please write this keyword in `mokit{}`. DO NOT WRITE this keyword in the Route
Section of .gjf file (i.e. '#p ...' line).

## 4.4.26 OtPDF
Specify the on-top pair density functional in a MC-PDFT calculation. This keyword has identical meaning with the keyword `KSDFT`/`FUNC` in `&MCPDFT` of (Open)Molcas. Currently available functionals are tPBE(default), tBLYP, tLSDA, trevPBE, tOPBE, ftPBE, ftBLYP, ftLSDA, ftrevPBE and ftOPBE. The functional name must be included in a pair of **single quotes**, i.e. `OtPDF='tPBE'`. The MC-PDFT output of `automr` would look like
```
Enter subroutine do_mcpdft...
MC-PDFT based on CASSCF orbitals.
MC-PDFT(4e,4o) using program openmolcas
$pymolcas -nt 6 h2o_uhf_gvb4_CASSCF_MCPDFT.input >h2o_uhf_gvb4_CASSCF_MCPDFT.out 2>&1

E(ref)      =       -75.90823031 a.u.
E(MC-PDFT)  =       -76.14952255 a.u.
E(TPBE) =       -76.14952255 a.u.
Leave subroutine do_mcpdft at Sat May 24 22:57:19 2025
```
where the `E(MC-PDFT)` is equal to `E(TPBE)` since only one functional tPBE is used here.

Users often want to compare energies calculated by different on-top pair density functionals. In such case, one can specify more than one functional such as `OtPDF='tBLYP;tPBE'`. There is no need to run another MC-PDFT job. When there are multiple functionals, they must be separated by the symbol `;`, please do not write any spacing ` ` or comma `,` in this pair of **single quotes**. The MC-PDFT output of `automr` would look like
```
Enter subroutine do_mcpdft...
MC-PDFT based on CASSCF orbitals.
MC-PDFT(4e,4o) using program openmolcas
$pymolcas -nt 6 h2o_uhf_gvb4_CASSCF_MCPDFT.input >h2o_uhf_gvb4_CASSCF_MCPDFT.out 2>&1

E(ref)      =       -75.90823031 a.u.
E(MC-PDFT)  =       -76.21854605 a.u.
E(TBLYP) =       -76.21854605 a.u.
E(TPBE) =       -76.14952255 a.u.
Leave subroutine do_mcpdft at Sat May 24 23:05:32 202
```
where the electronic energy of each functional is printed. `E(MC-PDFT)` is always equal to the 1st functional specified in `OtPDF='tBLYP;tPBE'`. If the keyword `Force` is also specified in `mokit{}`, only the analytical gradients of the 1st functional would be calculated.

For more details of on-top functionals, please refer to the (Open)Molcas manual. Note that the available functionals depends on your version of OpenMolcas or GAMESS. Old versions may not support some of the functionals.

Note that for Openmolcas >= v22.02, the on-top pair density functional keywords in .input file of OpenMolcas have been changed to T:PBE, FT:PBE, etc. The user need not worry about this problem in MOKIT, since `automr` will automatically detect the version of OpenMolcas and change the keyword tPBE into T:PBE if needed. Note that in GAMESS, the MC-PDFT is only supported for version >= 2019(R2).

See related keywords [MCPDFT_prog](#4420-mcpdft_prog) and [Force](#447-force).

## 4.4.27 DKH2
Request the 2nd order scalar relativistic Douglas–Kroll–Hess (DKH2) correction to the one-electron Hamiltonian. Note that: (1) The two keywords DKH2 and X2C are mutually exclusive, i.e. you can only write one of them. (2) You should use all-electron basis sets like 'cc-pVTZ-DK', 'x2c-TZVPall' or 'ANO-RCC-VDZ' for all-electron relativistic calculations. Pseudopotential should not be used. (3) It is strongly not recommended to use Cartesian-type function of basis set (severe numerical instability observed), please just use the default spherical harmonic functions.

Currently only the point nuclei charge distribution is supported. The DKH0 Hamiltonian is rough and thus not supported. These programs support the DKH2 Hamiltonian: Dalton, Gaussian, GAMESS, OpenMolcas, ORCA, Molpro, PSI4.

## 4.4.28 X2C
Request the scalar (i.e. spin-free) relativistic X2C (eXact-two-Component) corrections to the one-electron Hamiltonian. Note that: (1) The two keywords DKH2 and X2C are mutually exclusive, i.e. you can only write one of them. (2) You should use all-electron basis sets like 'cc-pVTZ-DK', 'x2c-TZVPall' or 'ANO-RCC-VDZ' for all-electron relativistic calculations. Pseudopotential should not be used. (3) It is strongly not recommended to use Cartesian-type function of basis set (severe numerical instability observed), please just use the default spherical harmonic functions.

Also note that by default, the RHF/UHF is performed using Gaussian called by `automr`, and GVB is performed using GAMESS called by `automr`. When you specify `mokit{X2C}`, the `HF_prog` will be switched to PySCF automatically. Since GAMESS does not support X2C currently, in this step the X2C will be replaced by DKH2. According to the limited tests of the developer jxzou, MOs resulting from DKH2 and X2C are similar and often converge in few cycles.

Currently only the point nuclei charge distribution is supported. These programs support the X2C Hamiltonian: BDF, OpenMolcas, Molpro, PSI4, PySCF. X2C will be supported in ORCA in the near future.

## 4.4.29 RI
Request to turn on the RI-JK approximation for two-electron integrals in CASSCF. Default is off. Please just write `mokit{RI}`, do not write 'mokit{RI=True}' or 'mokit{RI on}'. The other two types of RI approximations RI-J and RIJCOSX are not supported.

This option currently can only be used in CASSCF computations conducted by PySCF, OpenMolcas, Molpro, ORCA, or PSI4 programs. To learn more about the auxiliary basis set used in RI-JK approximation, see the following section.

## 4.4.30 RIJK_bas
Specify an auxiliary basis set for RI-JK approximation in CASSCF computations conducted by ORCA. Usually you do not need to specify this, since the automr program will automatically assign a proper auxiliary basis set according to the basis set (e.g. def2/JK for def2TZVP, cc-pVTZ/JK for cc-pVTZ). You can simply open the output file of automr and see what auxiliary basis set is assigned.

In the current version of OpenMolcas, there is no auxiliary basis set in it. The
`automr` program in MOKIT will automatically transformed the needed basis set file
and put that into `$MOLCAS/basis_library/jk_Basis/`.

## 4.4.31 F12
Request to turn on the F12 technique in NEVPT2 computations conducted by ORCA. F12 is not used by default. But if you turn on F12, [RI](#4429-ri) will be turned on as a byproduct.

This option currently can only be used in CASSCF and CASSCF-NEVPT2 computations conducted by ORCA program, i.e. you need to specify `CASSCF_prog=ORCA,NEVPT_prog=ORCA,F12` in mokit{}. To learn more about the near-complete auxiliary basis set used in F12 technique, see the following section.

## 4.4.32 F12_cabs
Specify a near-complete auxiliary basis set for the F12 technique in NEVPT2 computations conducted by ORCA. Usually you do not need to specify this, since the automr program will automatically assign a proper auxiliary basis set according to the basis set (e.g. cc-pVTZ-F12-CABS for cc-pVTZ-F12). You can simply open the output file of automr and see what CABS is assigned.

## 4.4.33 DLPNO
Request to turn on the DLPNO technique in NEVPT2 computations conducted by ORCA.
DLPNO is not used by default. But if you turn on DLPNO, RI (see 4.4.28) and FIC
(see 4.4.33) will be turned on as byproducts.

This option currently can only be used in CASSCF and CASSCF-NEVPT2 computations conducted by ORCA program, i.e. you need to specify `CASSCF_prog=ORCA,NEVPT_prog=ORCA,DLPNO` in mokit{}. Of course it can be combined with F12 to perform RI-DLPNO-FIC-NEVPT2-F12 computations for large systems, where the keywords should be `mokit{CASSCF_prog=ORCA,NEVPT_prog=ORCA,DLPNO,F12}`.

## 4.4.34 FIC
Request the FIC- variant of NEVPT2 (i.e. FIC-NEVPT2) to be used. By default SC-NEVPT2 is invoked if you specify NEVPT2 in route section `#p NEVPT2/...` and use PySCF/Molpro/OpenMolcas/ORCA program as `NEVPT_prog`. But if you specify `NEVPT_prog=BDF`, this option is turned on as a byproduct and FIC-NEVPT2 will then be performed. SC-NEVPT2 is not supported in BDF. FIC-NEVPT2 is not supported in PySCF.

## 4.4.35 ON_thres
When ist=5, this parameter is the threshold of natural orbital occupation numbers (NOON) for determining the number of active orbitals. Default value is 0.02, which means orbital occupation numbers 0.02~1.98 will be considered as active orbitals in subsequent CAS/DMRG calculations.

Note that when using ist=5, you should provide a .fch(k) file which contains paired natural orbitals, for example, UNO, UDFT NO, SUHF NO, etc. This is to ensure occupation numbers occur in a pairwise way (1-x, 1+x). Better not modify the default value unless you are an experienced user.

## 4.4.36 UNO_thres
When ist=1 or 2, this parameter is the threshold of UNO occupation numbers for determining the number of pairs in GVB computation. The default value is 0.00001 and it means all unoccupied UNOs with occupation numbers >1e-5 will be chosen (as well as their corresponding occupied UNOs) for subsequent orbital localization. The default value often corresponds to a full-valence computation of GVB. Similarly, setting UNO_thres=0.02 corresponds to the fact that any unoccupied UNOs with occupation numbers >0.02 will be chosen.

DO NOT modify the default value unless you are an experienced user.

## 4.4.37 excludeXH
Request the exclusion of inactive X-H bonds after normal GVB computation finished. For example, a normal GVB computation of the benzene molecule using cc-pVDZ basis set will lead to 15 pairs in total, which contains 9 pairs of C-C bonds and 6 pairs of C-H bonds. If the keyword `excludeXH` is specified in `mokit{}`, then a GVB(9) computation containing only C-C bonds will be automatically performed after GVB(15).

## 4.4.38 NMR
Request the calculation of nuclear shielding constants. Currently only the CASSCF method is supported. 
Gauge-Independent Atomic Orbital (GIAO) method is used to compute the NMR shielding tensors. Note that:

(1) This keyword should be written in mokit{}, not in the Gaussian keyword line `#p ...`.

(2) The chemical shift of an atom or element is the difference of nuclear shielding constants between the studied molecule and the standard reference molecule. For example, hydrogen atoms in tetramethylsilane(TMS) is usually used as the reference for chemical shifts in 1H-NMR.

(3) For practical computations of chemical shifts, it is recommended to use specially designed basis sets like pcSseg-1 or pcSseg-2. Larger basis sets like pcSseg-3, def2-QZVP or cc-pVQZ would be better but often too expensive.

(4) If you want to calculate NICS, please read [5.4.3 NICS of cyclobutadiene](./chap5-4.html#543-nics-of-cyclobutadiene).
If you want ICSS, please read [5.4.1 ICSS of the ground state of cyclobutadiene](./chap5-4.html#541-icss-of-the-ground-state-of-cyclobutadiene).

(5) You should use the OpenMP version of Dalton for this functionality, do not use MPI-parallelized version of Dalton.

(6) This functionality cannot be used for active space >(14,14), since there is no DMRG-GIAO implementation.

(7) MOKIT assumes the user uses 32-bit integer Dalton. The maximum memory allowed for 32-bit integer Dalton is around 16GB. So MOKIT will automatically reduce the memory to 16GB if the user specify >16GB in a NMR job.

## 4.4.39 ICSS
Request the calculation ICSS (Isochemical Shielding Surfaces). Currently only the CASSCF method is supported. 
Gauge-Independent Atomic Orbital (GIAO) method is used to compute the NMR shieldings. 
See the example `$MOKIT_ROOT/examples/automr/16-C4H4.gjf`.
Note that:

(1) This keyword should be written in `mokit{}`, not in the Gaussian keyword line (#p ...).

(2) This is an extremely time-consuming job. So you'd better have a large node/machine to compute all the generated files. 6-31G(d) or 6-31+G(d) basis set is recommended since larger basis set requires very long time.

(3) After the ICSS computation is accomplished, there would be a file like `*_ICSS.cub` generated. You can visualized it via GaussView, Multiwfn or VMD.

(4) You should use the OpenMP version of Dalton for this functionality, do not use MPI-parallelized version of Dalton.

(5) This functionality cannot be used for active space >(14,14), since there is no DMRG-GIAO implementation.

(6) MOKIT will submit 2, 3 or 4 Dalton jobs in parallel to accelerate the ICSS computation. The number of Dalton job is determined as three cases: (i) if %nproc is multiples of 4, then 4 jobs will be submitted; (ii) otherwise if %nproc is multiples of 3, then 3 jobs will be submitted; (iii) otherwise 2 jobs will be submitted. In these cases, the allowed maximum total memory is 64GB, 48GB and 32GB, respectively. This is because MOKIT assumes the user uses 32-bit integer of Dalton, which can only utilize up to 16GB.
See a detailed example in [5.4 ICSS and NICS](./chap5-4.html#54-icss-and-nics).

## 4.4.40 Nstates
Specify the number of roots to be averaged in SA-CASSCF computations. For example, Nstates=2 stands for 3 electronic states (ground state + two excited states). The default is to average states with the same spin. If you want to average S0/T1, you should also write the keyword [Mixed_Spin](#4441-mixed_spin).

## 4.4.41 Mixed_Spin
Specifying this keyword means that allowing electronic states with different spin multiplicities to be averaged in SA-CASSCF. If you want to write this keyword, just write Mixed_Spin. Do not write Mixed_Spin=.True. or Mixed_Spin=True. If this keyword is not specified, the default setting is to average states with the same spin.

## 4.4.42 Root
Specify the root which you are interested in State-Specific CASSCF (SS-CASSCF) calculations. Default value is 0 (ground state). `Root=1` stands for the first excited state. For example, if the ground state is S0, then `Root=1` stands for the S1 state. Note that this keyword is mutually exclusive to the keyword `Nstates` in [Nstates](#4440-nstates), since the latter one is used for SA-CASSCF. Currently dynamic correlation based on SS-CASSCF is not supported. The SS-CASSCF calculation is performed after the ground state CASSCF calculation.

## 4.4.43 GVB_conv
Modify/Set the density matrix convergence criterion in GAMESS GVB to be a desired threshold. The default threshold is different for two cases:

(1) 5D-4 (i.e. 0.0005 a.u.) for CASSCF and post-CASSCF calculations;  
(2) 1D-5 for GVB and GVB-BCCC calculations.

Usually there is no need to modify the default value. But if you want to use a less tight threshold, 1D-4 ~ 5D-4 is recommended, e.g. `GVB_conv=5D-4`. Note that only 4 characters are allowed for this parameter. Do not write 5.0D-4 since it exceeds the length limit. This keyword is equivalent to the keyword CONV in GAMESS (please read the documentation file docs-input.txt in GAMESS package if you want know more details).

There are two possible cases in which you may want to change the default GVB convergence threshold:

(1) When dealing with molecules which have many conjugated pi bonds (e.g. acene, zethrene), although the default orbital localization method Pipek-Mezey provides \\( \sigma \\) - \\( \pi \\) separated initial guess orbitals for GVB computation, the converged GVB orbitals may still be \\( \sigma \\) - \\( \pi \\) mixed. In that case you can specify keywords `mokit{LocalM=Boys,GVB_conv=5d-4}` and specify exactly the number of \\( \pi \\) bonds *n* in Route Section as GVB(*n*) (this is just a combination of keywords which have been explored by the developer jxzou and found often useful). One may wonder why the Boys localization method is used here. This is because we have explicitly specified GVB(*n*), the *n* pairs of UNOs near HONO are usually pure pi orbitals and it is safe to use Boys localization among \\( \pi \\) orbitals.

(2) When dealing with *d* or *f* transition metal (e.g. Fe) molecules, the GVB orbital optimization often takes many cycles to converge or even diverge in the end, but the first ~30 cycles are often reasonable, so we can use a less tight threshold to converge the GVB wavefuntion.

## 4.4.44 Skip_UNO
Specify the number of pairs of UNOs to be skipped during orbital localization. Default is 0. For example, `Skip_UNO=1` means that the HONO and LUNO will be kept unchanged when localizing UNOs. And `Skip_UNO=2` means that the HONO-1, HONO, LUNO and LUNO+1 will be kept unchanged when localizing UNOs. This is useful when GVB exists multiple SCF solutions. Using `Skip_UNO=1` you can probably obtain a biradical-like GVB solution (if the molecule indeed has significant biradical characters). It is recommended to choose the solution with the lowest GVB electronic energies for subsequent post-GVB
computations.

This keyword is invalid for keyword ist=3,4,5. It is also invalid when `mokit{ist=6}` is specified. But it is valid for keywords `mokit{ist=6,inherit}` since the keyword `inherit` will force skip_UNO=N to be inherited in the GVB/STO-6G computation.

## 4.4.45 Inherit
Request to inherit keywords and the number of GVB pairs (if explicitly specified) in GVB/STO-6G calculation from the target calculation. This keyword can only be used when ist=6. Default is not to inherit keywords. If you want to write this keyword, just write Inherit. Do not write Inherit=.True. or Inherit=True.

## 4.4.46 Npair
Specify the number of GVB pairs in a non-GVB (e.g. CASSCF) calculation. For example, the following input file will lead a GVB(24) -> CASSCF(10,10) calculation, where 24 means 16 C-C bonds and 8 C-H bonds:
```
%mem=48GB
%nprocshared=48
#p CASSCF/cc-pVDZ

mokit{ist=1,readuhf='naphthalene_cc-pVDZ_uhf.fch'}
```
But if you want to perform a GVB(5) -> CASSCF(10,10) calculation, which would save some time and obtain the same CASSCF result, you can modify the keywords into
```
mokit{ist=1,readuhf='naphthalene_cc-pVDZ_uhf.fch',Npair=5}
```

## 4.4.47 FcGVB
Request to freeze all doubly occupied orbitals in GVB calculations. Do not write FcGVB=.T., FcGVB=.True., or FcGVB=True. Just specifying FcGVB will work, i.e. `mokit{FcGVB,...}`. This keyword is useful for obtaining the GVB solution with pure \\( \pi \\) orbitals in calculations of non-planar polycyclic hydrocarbons. If you want to calculate the S-T gap, remember to specify FcGVB in both singlet and triplet cases.

By default, for CASCI/CASSCF and post-CAS calculations, FcGVB is automatically enabled in MOKIT. While for GVB and GVB-BCCC calculations, FcGVB is automatically disabled. The keyword `NoFcGVB` prevents freezing doubly occupied orbitals.

## 4.4.48 OnlyXH
Request to keep only X-H bonds after a normal GVB computation finished. For example, a normal GVB computation of the benzene molecule using cc-pVDZ basis set will lead to 15 pairs in total, which contains 9 pairs of C-C bonds and 6 pairs of C-H bonds. If the keyword `OnlyXH` is specified in `mokit{}`, then a GVB(6) computation containing only C-H bonds will be automatically performed after GVB(15). This keyword can be viewed as an opposite option of [excludeXH](#4438-excludexh).

## 4.4.49 Xmult
Specify the spin multiplicity of the target excited state in a SS-CASSCF calculation. This keyword is usually used along with `root` in Section [Root](#4442-root). If the spin multiplicity in the input file is 1 (i.e. assuming a singlet ground state), here are some examples of calculating the target excited state:  
(1) `mokit{root=1}` means the S<sub>1</sub> state;  
(2) `mokit{root=1,Xmult=1}` is identical to (1);  
(3) `mokit{root=1,Xmult=3}` means the T<sub>1</sub> state;  
(4) `mokit{root=2,Xmult=1}` means the S<sub>2</sub> state.

## 4.4.50 noDMRGNO
Request not to generate natural orbitals in a DMRG-CASCI calculation. Only valid for a DMRG-CASCI job. This keyword would save some time when one wants to check whether the DMRG-CASCI electronic energy converges with [maxM](#4422-maxm). After the user confirms a suitable `maxM`, he/she can remove this keyword and perform a single point calculation to generate DMRG NOs.

## 4.4.51 HFonly
Request the `automr` program to terminate after the HF calculations are finished. This is useful when one wants to perform the sfX2C-UHF calculation using fragment guess. An input example is shown below

```
%mem=200GB
%nprocshared=48
#p GVB/gen guess(fragment=5)

mokit{HF_prog=PySCF,DKH2,HFonly}
...
```

`automr` will firstly call Gaussian to generate the fragment guess, then transfer initial guess orbitals to PySCF and call PySCF to perform the sfX2C-UHF calculation. After UHF is finished, `automr` will terminate and no GVB calculation will be performed. Here the keyword `DKH2` is for GVB calculation and will not be used in the UHF calculation.

## 4.4.52 block_mpi
Request the MPI version of Block program to be used in DMRG calculations. By default `automr` would call the OpenMP version of the Block2 program since it is faster than MPI version in a single node. Note that this keyword only changes the parallelism of DMRG-CASCI and/or DMRG-CASSCF calculations, but the NEVPT2 calculation after DMRG always utilize MPI parallelism (which requires `mpi4py` to be installed). Usually you do not need this keyword unless you want to perform tests or debug.

## 4.4.53 LocDocc
Request to perform the orbital localization upon the doubly occupied orbitals in a GVB job. This GVB job can be a target calculation, or just an intermediate step in a CASCI/CASSCF job. Note that this localization does not change the electronic energy of GVB/CASCI/CASSCF. It is just of convenient usage for some users, or for convenience of identifying core orbitals. The localization method is PM by default, and it is controlled by [LocalM](#445-localm).

